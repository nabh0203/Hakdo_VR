# Hakdo_VR
## $\Large\bf{능력을~~“~Verify~”~하다}$

> $\large\sf {
나의~능력을
}$   **$\Large\sf {“ 증명(\sf\bold{Verify}) ”}$**  $\large\sf {할~수~있게~해준~\bold{콘텐츠}}$
> 

<aside>
❗ 계원예술대학교 졸업 전시 작품에 출품하였던 **“학도”** 라는 프로젝트 입니다.

학도병이 참전하였던 장사리상륙작전을 모티브 삼아 제작하였던 **VR 콘텐츠** 입니다.

해당 콘텐츠를 통해 졸업작품 최우수작을 수상하였으며

제가 가지고 있는 능력을 ***“증명”***  할수 있게 해준 콘텐츠 입니다.

</aside>

---

## $\Large\bf{학도병~이란~무엇인가~?}$

![Frame 73.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/681593ad-8f5c-4ccf-8add-913e03267f19/Frame_73.png)

<aside>
🪖 **“저희가 펜을 들수 있었던 이유는 그들이 총을 들었기 때문입니다.”**

**학도병 : 6·25전쟁 때 학생의 신분으로 참전한 의용병.** 

6.25 전쟁이 일어났던 1950년 저희와 같은 나이에 조국을 지키겠다는 신념 하나만으로

조직된 의용군입니다.

6,25 전쟁 작전 중 유명한 작전이라 하면 모두들 인천상륙작전을 생각하실겁니다.
그러나 이 작전이 성공하기 위해 동시에 진행되었던 작전이 하나 있었습니다.

바로 **“장사상륙작전”** 입니다. 이 작전은 인천상륙작전이 성공하기 위해 실행되었던 
작전이며 주 임무로는 보급로 차단 및 적을 퇴치하는 임무였습니다.

그러나 두개의 작전을 동시에 진행하기에는 작전인원들이 턱없이 부족하였습니다.

어쩔수 없이 학생신분으로 전쟁에 참여한 **학도병** 들이 대거 참전한 작전이며

오직 조국 해방만을 위해 희생당하였습니다.

</aside>

## $\Large\bf{주제~선정~이유}$

![Group 27148.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/823b9a33-d085-4102-b8ad-033829f6fb7c/Group_27148.png)

<aside>
<img src="/icons/pencil_gray.svg" alt="/icons/pencil_gray.svg" width="40px" /> **10대(7명)중 1명 만이 6ㆍ25 전쟁이 ‘1950년에 일어났다’고 정확하게 응답**

해당 주제를 선정한 이유는 총 3가지 였습니다.

> **1. 역사적 교육 인식 문제**
> 
> 
> **2. 소실되어 가는 역사 자료**
> 
> **3. 대한민국 국민으로서의 정체성 형성**
> 

일단 첫번째 이유로는 바로 **역사적 교육이 올바르게 되고 있지 않다** 였습니다.

위 그래프를 보시면 **6,25 전쟁이 몇 년도에 일어났을까?** 에 대한 자료입니다.

6.25 전쟁은 저희가 절대 잊어서는 안되는 아픈 기억이며 나이대 를 불문하고 
모두가 다 알아야 하는 역사 입니다.

그러나 자료통계에 따르면 역사적 교육을 제대로 알아야 하는 10대,20대 청년들의
6.25 전쟁에 대한 정보가 부족하다는것을 알 수 있었습니다.

두번째 이유는 **소실되어 가는 역사 자료** 입니다.

첫번째 이유와 연관되어 있으며 10대,20대 청년들이 6.25 에 대한 정보가 부족한 이유는
바로 역사적 자료가 점점 간소화 되가며 사라지고 있다는 사실을 알수 있었습니다.

자료조사에 따르면 “**10대부터 접하는 교과서의 내용들이 이전 세대 보다 6·25 전쟁 
관련 내용이 줄어들어 기억하고 있는 내용 자체가 적을 수밖에 없다”** 
라는 자료를 발견하게 되었습니다. 

세번째 이유는 **대한민국 국민으로서의 정체성 형성** 입니다.

해당 작전과 관련된 내용이 터무니없이 적어 해당 사건을 국민들이 많이 알지 못한다는
것은 사실입니다. 

저희는 이러한 역사적 사건들이 절대 잊혀저서는 안되며 “장사상륙작전” 의외의 사건들
조차 학생들이 알지 못한다는 점을 알고 너무나도 안타까웠습니다.

대한민국 국민으로서 6.25 전쟁은 절대적으로 잊혀져서는 안되는 비통한 사건인게 
분명하며 그 중에서 “장사상륙작전” 조차 모르는 10대 20대 가 많다라는것은
**”대한민국 국민으로서의 정체성을 잃을수도 있다”** 라는 생각을 가지게되었습니다.

</aside>

<aside>
💡 **$\large\bf{장사상륙~작전~VR~콘텐츠}$**

**그리하여 저희는 이러한 문제점을 해결하기 위해 잊혀져서는 안 될 역사적 사건을** 

**현대 학생과 나이대가 같은 학도병들의 이야기를 나누고자 학도병들이 가장 많은** 

**참전을 한 장사상륙작전에 관하여 VR콘텐츠를 제작하였습니다.**

</aside>

## $\Large\bf{배경}$

![http://www.meditechnews.com/news/articleView.html?idxno=6620](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/5c9e1c83-8094-41e5-8ed7-7addd417a86a/unnamed.jpg)

http://www.meditechnews.com/news/articleView.html?idxno=6620

<aside>
🪖 **장사리 : 잊혀진 영웅들**

프로젝트를 시작하기에 앞서 저희는 장사상륙작전에 대한 지식이 필요했습니다.
그러던 중 2019년도에 개봉한 **장사리 : 잊혀진 영웅들** 이라는 영화를 발견하였습니다.
해당 영화는 장사상륙작전을 배경으로 만들어진 영화이며 프로젝트를 진행하기에
래퍼런스로 삼기에 매우 좋은 콘텐츠 였습니다.

그리하여 저희는 해당 영화의 스토리라인을 각색하여 스토리라인을 재 구축한 뒤
영화의 나오는 오브젝트들을 하나하나 살펴보며 직접 모델링을 제작하였고
실제 작전에 관련한 내용을 살펴보며 진행하였습니다.

회의를 진행함에 있어 해당 프로젝트를 사용자들에게 몰입감을 주면서 체험을 시키기
위해선 캐릭터 성 모델이 아닌 실사 모델을 통해 실사감을 주자 라는 의견이 나와
모든 모델링을 실사 위주의 모델링으로 구성 하였습니다.

</aside>

<실제 제작한 맵 모델링>

![Rectangle 42.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/2dc4dac7-c7fc-4b83-8d1f-76b78f342732/Rectangle_42.png)

![Rectangle 2676.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/d71420a3-dab3-4536-bc09-931474e51be5/Rectangle_2676.png)

## $\Large\bf{개발~목표}$

<aside>
🎮 **FPS 장르**
먼저 해당 프로젝트를 진행함에 있어 팀원들과 몇가지 의논점이 있었습니다.

**1. VR 을 통해 어떤식으로 사용자에게 실제와 같은 체험을 시켜줄것인지?**

**2. VR 조작은 어떻게 구현을 할것인지?** 

**3. 전쟁 중 사격,폭발 과 같은 기능은 어떻게 할건지?**

위 3가지를 고민하게 되었습니다.

먼저 첫번째 의논점인 **VR을 통해 실사감을 어떻게 느끼게 할것인지?** 입니다.

해당 의논에 있어서 저희는 기존에 존재하는 **OVR Intergration** 을 통해 제작하기로
결정 하였습니다. 
**OVR Intergration** 은 **Unity** 에서 VR을 사용할수 있게 도와주는 **Asset** 입니다.

첫번째 의논점에 대한 해결책으로는 해당 **Asset** 에 존재하는 **OVR Camera** 에 반동을 
넣어 **“실제 걸으면서 느끼는 반동을 주어 실제로 걷는듯한 느낌을 주자”** 라는 결론이 
지어졌습니다.

두번째 의논점으로는 **VR 조작** 이 있었습니다.

조작에 관련해서 이미 제작하였던 프로젝트인 “버디” 에서 사용된 텔레포트를 
사용하자 라는 의논이 나왔지만 실사적인 느낌을 주기 위해선 VR 컨트롤러의
**조이스틱**을 사용하여 조작하자는 의논이 나왔습니다.

그리하여 두번째 의논점의 해결책으로는 **“조이스틱을 사용하여 조작하자”** 라는
결론이 도출 되었습니다.

세번째 의논점으로는 **사격,폭발 기능을 어떻게 구현할 것 인가?** 입니다.

이 의논점에 대해서는 매우 쉽게 해결하였습니다. VR 기기 컨트롤러 특성상 
좌 우 컨트롤러에 **Trigger Button** 과 **Grip Button** 이 존재하며 이 버튼들을 이용하여
기능을 구현할수 있게 기획하였습니다.

먼저 **Trigger Button** 을 통해 사격기능을 구현하고 **Grip Button** 을 이용하여 
장전 및 수류탄 잡기,던지기 상호작용이 가능하게 기획하였습니다.

이러한 기능들을 VR FPS 장르를 래퍼런스 삼아 기능을 제작하였습니다.

</aside>

## $\Large\bf{개발~과정}$

<aside>
<img src="/icons/gear_gray.svg" alt="/icons/gear_gray.svg" width="40px" /> **OVR Intergration 사용**

</aside>

먼저 개발목표에서 컨트롤러 설정을 적은것 처럼 **OVR Intergration** 을 사용하였습니다.

해당 **Asset** 의 특징으로는 예제들을 활용하여 예제의 스크립트들을 참조,수정하여 사용할수 
있다라는 장점이 있었습니다.

이러한 장점들은 개발하는데에 있어서 시간을 단축 시킬수 있었으며 좀 더 최적화된 스크립트를
작성 할수 있었습니다.

## $\large\bf{Scripts}$

### Controller

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Controller : MonoBehaviour
{
    public float speedForward = 12f; //전진 속도
    public float speedSide = 12f; //옆걸음 속도
    public AudioClip walkingSound; // 발걸음 소리

    private CharacterController characterController;
    private Transform vrCameraTransform; //Center Eye Camera transform
    private AudioSource audioSource;

    void Start()
    {
        characterController = GetComponent<CharacterController>();
        if (characterController == null)
        {
            Debug.LogError("Failed to find Character Controller.");
        }

        vrCameraTransform = GameObject.Find("CenterEyeAnchor").transform;
        if (vrCameraTransform == null)
        {
            Debug.LogError("Failed to find CenterEyeAnchor.");
        }

        // AudioSource 컴포넌트를 가져오거나 추가
        audioSource = GetComponent<AudioSource>();
        if (audioSource == null)
        {
            audioSource = gameObject.AddComponent<AudioSource>();
        }
        // 발걸음 소리 설정
        audioSource.clip = walkingSound;
        audioSource.loop = true; // 사운드를 반복재생
    }

    void Update()
    {
        MovePlayer();
    }

    void MovePlayer()
    {
        float dirX = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick).x;
        float dirZ = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick).y;

        Vector3 moveDir = new Vector3(dirX * speedSide, 0, dirZ * speedForward);

        // Transform the movement vector to be relative to the VR camera's direction.
        moveDir = vrCameraTransform.TransformDirection(moveDir);

        characterController.SimpleMove(moveDir);

        // 플레이어가 움직이면 발걸음 소리 재생, 멈추면 멈춤
        if (moveDir != Vector3.zero && !audioSource.isPlaying)
        {
            audioSource.Play();
        }
        else if (moveDir == Vector3.zero)
        {
            audioSource.Stop();
        }
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **Controller 스크립트 제작중 중점 사항**

> **OVR Intergration** 에 존재하는 **OVR Player** 스크립트를 활용하여 컨트롤러 기능을
> 
> 
> 제작하려고 했으나 혹시나 하는 오류 문제들로 인하여 기존의 스크립트들을 참고
> 
> 하여 제작하였습니다.
> 
> 해당 스크립트 변수부터 살펴 보겠습니다.
> 
> ```csharp
>  public float speedForward = 12f; //전진 속도
>  public float speedSide = 12f; //옆걸음 속도
>  public AudioClip walkingSound; // 발걸음 소리
> 
>  private CharacterController characterController;
>  private Transform vrCameraTransform; //Center Eye Camera transform
>  private AudioSource audioSource;
> ```
> 
> 먼저 **speedForward**,**speedSide** 변수입니다.
> 
> 해당 변수는 사용자가 컨트롤러의 **Thumbstick** 을 사용하여 움직였을때 이동하는 
> 속도를 지정할수 있는 변수 입니다 해당 변수의 숫자를 바꾸면 원하는 속도 값으로
> 교체할수 있도록 제작하였습니다.
> 
> ---
> 
> 그 다음 **walkingSound** 변수입니다.
> 
> 해당 변수는 사용자가 조작을 통해 움직였을때 발소리를 재생시키기 위한 변수이며
> **AudioClip** 을 사용하여 원하는 음악을 지정할수있게 생성하였으며 **audioSource**
> 와 같이 사용됩니다.
> 
> ---
> 
> **characterController** 와 **vrCameraTransform** 변수입니다.
> 
> 먼저 **characterController** 변수는 Unity 에 존재하는 컴포넌트인 **CharacterController** 을 참조 할 수 있게 해주는 변수 입니다.
> 
> 다음 변수로는 **vrCameraTransform** 변수이며 해당 변수를 통해 VR 기기의 
> 메인카메라의 위치값을 받아옵니다. 
> 
> ---
> 
> **Start() 함수**입니다.
> 
> ```csharp
> void Start()
>     {
>         characterController = GetComponent<CharacterController>();
>         if (characterController == null)
>         {
>             Debug.LogError("Failed to find Character Controller.");
>         }
> 
>         vrCameraTransform = GameObject.Find("CenterEyeAnchor").transform;
>         if (vrCameraTransform == null)
>         {
>             Debug.LogError("Failed to find CenterEyeAnchor.");
>         }
> 
>         // AudioSource 컴포넌트를 가져오거나 추가
>         audioSource = GetComponent<AudioSource>();
>         if (audioSource == null)
>         {
>             audioSource = gameObject.AddComponent<AudioSource>();
>         }
>         // 발걸음 소리 설정
>         audioSource.clip = walkingSound;
>         audioSource.loop = true; // 사운드를 반복재생
>     }
> ```
> 
> 실행시 **characterController** 변수를 통해 해당 스크립트가 컴포넌트 된 오브젝트가
> **CharacterController** 컴포넌트를 참조할수 있게 합니다.
> 
> 만약 참조 되지 않았다면 **LogError** 를 통해 **Console** 창에 오류를 표시하게 설정 
> 하였습니다.
> 
> 그 다음 **vrCameraTransform** 변수를 통해 **CenterEyeAnchor** 라는 이름을 가진
> 오브젝트의 위치값을 지정해줍니다.
> 
> 만약 위치값을 받지 못했다면 위와 동일하게 **LogError** 를 통해 **Console** 창에 오류를 표시하게 설정 하였습니다.
> 
> **audioSource** 변수에는 **AudioSource** 컴포넌트를 참조할수 있게 지정한 뒤
> 
> 만약 참조되지 않았다면 해당 스크립트가 컴포넌트 된 오브젝트가 **AudioSource** 
> 컴포넌트를 참조할수 있게 합니다.
> 
> 지정한 **walkingSound** 를 **audioSource.clip** 으로 설정 한 뒤 **loop** 를 통해 반복되게
> 설정하였습니다.
> 
> ---
> 
> **Update()** 함수입니다.
> 
> ```csharp
> void Update()
>     {
>         MovePlayer();
>     }
> ```
> 
> 해당 함수에서는 **MovePlayer();** 함수를 실행중에 계속 실행되게 설정 하여
> 사용자가 조작을 할수 있게 설정하였습니다.
> 
> ---
> 
> 마지막으로 **MovePlayer()** 함수입니다.
> 
> ```csharp
> void MovePlayer()
>     {
>         float dirX = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick).x;
>         float dirZ = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick).y;
> 
>         Vector3 moveDir = new Vector3(dirX * speedSide, 0, dirZ * speedForward);
> 
>         // Transform the movement vector to be relative to the VR camera's direction.
>         moveDir = vrCameraTransform.TransformDirection(moveDir);
> 
>         characterController.SimpleMove(moveDir);
> 
>         // 플레이어가 움직이면 발걸음 소리 재생, 멈추면 멈춤
>         if (moveDir != Vector3.zero && !audioSource.isPlaying)
>         {
>             audioSource.Play();
>         }
>         else if (moveDir == Vector3.zero)
>         {
>             audioSource.Stop();
>         }
>     }
> ```
> 
> 해당 스크립트는 사용자 조작에 관련된 스크립트 입니다.
> 
> 앞서 설명드려할 점으로는 **Primary** 와 **Secondary** 의 차이점입니다.
> 
> **Primary** 는 왼쪽 컨트롤러의 버튼 함수 앞에 붙는 명칭이며
> **Secondary** 는 오른쪽 컨트롤러의 버튼 함수 앞에 붙는 명칭입니다.
> 
> 저희는 왼쪽 컨트롤러를 활용하여 조작을 진행하고 오른쪽 컨트롤러를 사용하여
> 사격 및 수류탄 기능을 구현하였습니다. 
> 
> 먼저 함수 자체적으로 변수를 설정하여 **dirX**,**dirZ** 라는 변수를 생성 하였습니다.
> 해당 변수는 **OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick)** 을 통해
> **Thumbstick** 의 **상**,**하**,**좌**,**우** 를 관여해주는 변수 입니다.
> 
> 그 다음 **Vector3** 속성 변수인 **moveDir** 을 생성하여 위치를 관여하고 **앞**,**뒤**,**좌**,**우** 
> 로 사용자가 **Thumbstick** 을 움직인 만큼과 **speedSide** , **speedForward** 을
> ****곱한 값 만큼 ****이동할 수 있게 설정 하였습니다.
> 
> **moveDir** 변수는 **vrCameraTransform** 변수의 속성인 **TransformDirection**에 
> 매개변수로 받아 사용자가 고개를 돌렸을 시 고개를 돌린 위치에서 **앞**,**뒤**,**좌**,**우** 로 
> 움직일 수 있게 설정했습니다.
> 
> 그 다음 **characterController** 변수의 **CharacterController** 속성인 **SimpleMove**
> 매개변수를 **moveDir 로 지정하여 CharacterController** 에도 관여할수 있게
> 하였습니다.
> 
> 마지막으로 사용자가 조작하여 움직이면 미리 설정한 **audioSource** 을 반복 재생하고
> 움직이지 않는다면 **audioSource** 을 멈추게 설정하였습니다.
> 
</aside>

### CamerWalk

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CamerWalk : MonoBehaviour
{
		// 플레이어의 변형위치변수
    public Transform playerTransform; 
    // 카메라의 벡터3의 위치값                                  
    public Vector3 offset; 
    //변수
    public float bobbingSpeed = 2f;
    //  카메라 움직임 값
    public float bobbingAmountY = 0.2f;
    // Y축 위치 값
    public float bobbingAmountX = 0.1f;
    //  X축 위치 값

    private Vector3 defaultPos;
    // 벡터3 의 초기값 변수

    private void Start()
    {
        // 초기값에 Public 설정한 값 할당
        defaultPos = offset;
        // y축은 1.8로 설정하고 x축과 z축은 초기값 그대로 유지
        offset = new Vector3(offset.x, 1.8f, offset.z);
    }

    private void Update()
    {
        // Oculus 컨트롤러의 왼쪽 조이스틱 입력 값을 가져와
        Vector2 thumbstick = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);

        // 만약 조이스틱 y축이 0보다 클 시 즉 위로 향할 시 
        if (thumbstick.y > 0 || thumbstick.x > 0 || thumbstick.x < 0 || thumbstick.y < 0) // When the joystick of the left controller is pointed up
        {
            //Debug.Log("Moving joystick up");
            //Mathf.sin함수로 시간 과 스피드값을 y축으로 웨이브처럼 이동시킴과 동시에
            float wavesliceY = Mathf.Sin(Time.time * bobbingSpeed);
            // x축도 이동시킨다 추가로 0.5f를 곱하여 좀 더 빠르게 설정
            float wavesliceX = Mathf.Sin(Time.time * bobbingSpeed * 0.5f);
            // y,x 변형된 값들에서 waveslice 형태와 위치값을 곱함과 동시에 pos.y를 해서 위치할당 
            offset.y = Mathf.Abs(defaultPos.y + wavesliceY * bobbingAmountY);
            offset.x = defaultPos.x + wavesliceX * bobbingAmountX;
            //Debug.Log(offset);
        }
        else
        {
            // 만약 놓을 시 다시 원래 초기 위치 값으로 돌아옴
            offset = defaultPos;
        }

        // 마지막으로, 계산된 위치 값을 이 객체의 로컬 위치 값으로 설정
        transform.localPosition = offset;
        /*Debug.Log(transform.localPosition);*/
    }
}
```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **CamerWalk 스크립트 제작중 중점 사항**

> 사용자가 VR 기기를 착용하여 조작하였을때 실제 걷는듯한 반동을 주기위해 
제작된 스크립트 입니다.
> 
> 
> 
> 해당 스크립트 변수부터 살펴 보겠습니다.
> 
> ```csharp
> // 플레이어의 변형위치변수
> public Transform playerTransform; 
> // 카메라의 벡터3의 위치값                                      
> public Vector3 offset; 
> //  카메라 움직임 값
> public float bobbingSpeed = 2f;
> // Y축 위치 값
> public float bobbingAmountY = 0.2f;
> //  X축 위치 값
> public float bobbingAmountX = 0.1f;
> // 벡터3 의 초기값 변수
> private Vector3 defaultPos;
> ```
> 
> 먼저 **playerTransform** 변수입니다.
> 
> 해당 변수는 사용자의 **Unity** 안에서의 위치를 받아오는 변수입니다.
> 
> ---
> 
> 그 다음 **offset** 변수입니다.
> 
> **VR** 카메라의 위치값을 받아오는 변수이며 해당 변수를 통해 카메라와 사용자
> 사이의 상대적 위치를 계산해주는 변수입니다.
> 
> ---
> 
> **bobbingSpeed** 와 **bobbingAmountX** , **bobbingAmountY** 변수입니다.
> 
> 먼저 **bobbingSpeed** 변수는 카메라의 반동 속도를 조절하는 변수입니다.
> 
> **bobbingAmountX** , **bobbingAmountY** 변수들은 카메라가 **X**,**Y** 축에 기입한
> 위치 까지만 반동이 적용되게 해주는 변수입니다.
> 
> ---
> 
> 마지막 으로 **defaultPos** 변수입니다.
> 
> 해당 변수는 **offset** 변수의 값을 **Start()** 부분에서 할당하기 위한 변수입니다.
> 
> ---
> 
> **Start() 함수**입니다.
> 
> ```csharp
> private void Start()
>     {
>         // 초기값에 Public 설정한 값 할당
>         defaultPos = offset;
>         // y축은 1.8로 설정하고 x축과 z축은 초기값 그대로 유지
>         offset = new Vector3(offset.x, 1.8f, offset.z);
>     }
> ```
> 
> 실행시 **defaultPos** 변수에 설정한 카메라의 위치값을 할당해줍니다.
> 
> 그 다음 **offset** 변수에 **Y**축은 **1.8** 로 설정하여 실제 사람의 키와 비슷하게 
> 설정하였습니다.
> 
> ---
> 
> **Update()** 함수입니다.
> 
> ```csharp
>  private void Update()
>     {
>         // Oculus 컨트롤러의 왼쪽 조이스틱 입력 값을 가져와
>         Vector2 thumbstick = OVRInput.Get(OVRInput.Axis2D.PrimaryThumbstick);
> 
>         // 만약 조이스틱 y축이 0보다 클 시 즉 위로 향할 시 
>         if (thumbstick.y > 0 || thumbstick.x > 0 || thumbstick.x < 0 || thumbstick.y < 0) // When the joystick of the left controller is pointed up
>         {
>             //Debug.Log("Moving joystick up");
>             //Mathf.sin함수로 시간 과 스피드값을 y축으로 웨이브처럼 이동시킴과 동시에
>             float wavesliceY = Mathf.Sin(Time.time * bobbingSpeed);
>             // x축도 이동시킨다 추가로 0.5f를 곱하여 좀 더 빠르게 설정
>             float wavesliceX = Mathf.Sin(Time.time * bobbingSpeed * 0.5f);
>             // y,x 변형된 값들에서 waveslice 형태와 위치값을 곱함과 동시에 pos.y를 해서 위치할당 
>             // Mathf.Abs 함수는 절대값을 반환하므로, 계산된 값이 음수가 되더라도 양수로 변환된다.
>             // 이는 카메라가 아래로 가는 것을 방지한다. 
>             offset.y = Mathf.Abs(defaultPos.y + wavesliceY * bobbingAmountY);
>             offset.x = defaultPos.x + wavesliceX * bobbingAmountX;
>             //Debug.Log(offset);
>         }
>         else
>         {
>             // 만약 놓을 시 다시 원래 초기 위치 값으로 돌아옴
>             offset = defaultPos;
>         }
> 
>         // 마지막으로, 계산된 위치 값을 이 객체의 로컬 위치 값으로 설정
>         transform.localPosition = offset;
>         /*Debug.Log(transform.localPosition);*/
>     }
> ```
> 
> 먼저 **왼쪽 컨트롤러의 Thumbstick** 값을 **thumbstick** 이라는 변수에 저장합니다.
> 
> 만약 **Thumbstick** 이 **X** , **Y** 축으로 이동하였을때 0보다 크다면 반동을 실행 하고
> 아니라면 반동을 멈추어 **Start()**에서 설정하였던 **defaultPos** 의 값으로 이동하게
> 설정하였습니다.
> 
> 이제 카메라 반동식 에 대해 풀이 하겠습니다.
> 
> **wavesliceX** , **wavesliceY** 라는 변수를 생성 하여 **Mathf.Sin** 을 활용하여 Y 축에선 
> 웨이브 형식으로 이동할수 있게 설정 **X** 축에서는 **Y**축 보다 **0.5** 더 빠르게 설정
> 하였습니다.
> 
> 그 다음 **offset** 변수의 **X** , **Y** 축 에 반동 속도 값을 지정하였습니다.
> 
> 먼저 **defaultPos** 의 **X**, **Y** 는 기존의 카메라 위치값을 뜻하고  
> **wavesliceY * bobbingAmountY** 는 반동의 크기를 조절하기 위하여 작성했습니다.
> 여기서 **bobbingAmountY** 의 값이 클수록 반동의 크기가 더 커집니다.
> 
> **Mathf.Abs** 을 사용한 이유로는 Y축에서 아래로 이동하는 반동을 없애기 위해 **Mathf.Abs** 을 사용하여 카메라가 아래로 이동하는것을 방지 하였습니다.
> 
> 마지막으로 **If 문** 안에 실행문이 끝난다면 다시 **offset** 위치로 돌아가게 
> 설정하였습니다.
> 
</aside>

### Raycast

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Raycast : MonoBehaviour
{
    [SerializeField] private GameObject firePos;  //총알 생성 위치
    public Transform FirePos;
    private LineRenderer laserLine; // 레이저 포인터
    public GameObject bullet; //발사할 총알이펙트
    public GameObject bullet2; //발사할 총알이펙트
    public GunWithHands LeftHand; //왼손 모델링
    public bool ReloadBullet = true;//장전여부
    private bool Hold = false;//잡기
    public int b = 0;//발사한 총알 갯수
    public AudioClip sound; // 재생할 사운드 클립
    public AudioSource audioSource; // AudioSource component를 참조하는 public 변수를 선언합니다. Unity Editor에서 이 변수에 AudioSource component를 연결해주세요.
    public AudioClip audioClip; // 재생하고 싶은 오디오 클립을 참조하는 public 변수를 선언합니다. Unity Editor에서 이 변수에 원하는 오디오 클립을 연결해주세요.

    void Start()
    {
        Hold = false;
        laserLine = GetComponent<LineRenderer>();
        if (laserLine == null)
        {
            laserLine = this.gameObject.AddComponent<LineRenderer>();
            laserLine.material = new Material(Shader.Find("Standard"));
            laserLine.startColor = Color.red;
            laserLine.endColor = Color.red;
            laserLine.startWidth = 0.01f;
            laserLine.endWidth = 0.01f;
        }
        laserLine.positionCount = 2;
    }

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("R"))
        {
            Debug.Log("잡다");
            Hold = true;
        }

        if (other.gameObject.CompareTag("Bullet") && b == 5)
        {
            Debug.Log("장전");
            ReloadBullet = true;
            Destroy(other.gameObject);
            audioSource.PlayOneShot(audioClip);
            StartCoroutine(Reload());
            //other.gameObject.SetActive(false);
            LeftHand.FalseLeftHand();

        }
    }

    private void OnTriggerExit(Collider other)
    {
        if (other.CompareTag("R"))
        {
            Debug.Log("놓다");
            Hold = false;
        }
    }
    void Update()
    {

        //trigger 누를 때
        if (OVRInput.GetDown(OVRInput.Button.SecondaryIndexTrigger) && b <= 5 && Hold == true && ReloadBullet == true)
        {

            b++;
            TriggerShoot();
            //Invoke("TriggerShoot",0f);
            Debug.Log("누름");

            GameObject projectile = Instantiate(bullet2, FirePos.position, FirePos.rotation);

            Destroy(projectile, 0.1f); // Make sure to destroy the instantiated object not the original prefab.
            GameObject projectile2 = Instantiate(bullet, FirePos.position, FirePos.rotation);
            AudioSource audioSource = projectile2.AddComponent<AudioSource>();
            audioSource.clip = sound;
            audioSource.Play();
            Destroy(projectile2, 1f); // Make sure to destroy the instantiated object not the original prefab.
            if (b == 5)
            {
                Debug.Log("장전필요");
                ReloadBullet = false;
                LeftHand.ActiveLeftHand();
            }

        }
        DrawLaser(firePos.transform.position, firePos.transform.position + firePos.transform.forward * 100);
        // 함수는 지정된 위치에서 지정된 반경 내에 있는 모든 Collider를 반환합니다.이 결과를 순회하며 "Bullet" 태그가 있는지 확인
    }
    public IEnumerator Reload()
    {
        yield return new WaitForSeconds(1f);
        b = 0;
    }

    public void TriggerShoot()
    {
        if (Hold && b < 6)
        {
            Ray ray = new Ray(firePos.transform.position, firePos.transform.forward);
            RaycastHit hitInfo;

            if (Physics.Raycast(ray, out hitInfo))
            {
                if (hitInfo.collider.tag == "Anemy")
                {
                    Destroy(hitInfo.transform.gameObject);
                }

                DrawLaser(ray.origin, hitInfo.point);
            }
            else
            {
                DrawLaser(ray.origin, ray.origin + ray.direction * 100);
            }
        }
    }

    void DrawLaser(Vector3 startPosition, Vector3 endPosition)
    {
        laserLine.SetPosition(0, startPosition);
        laserLine.SetPosition(1, endPosition);
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **Raycast 스크립트 제작중 중점 사항**

> 사격과 사격 이펙트를 가지고 있는 스크립트 입니다.
해당 스크립트의 특징으로는 **레이캐스트(Raycast)** 라는 기능을 사용하여 사격 기능을 제작하였습니다.
> 
> 
> 
> **레이캐스트(Raycast)** 란?
> 
> > **Unity** 에서 사용되는 기능 중 하나이며 **가상의 선(레이)** 를 쏴 선이 통과하는
> 객체를 탐지하는 기능입니다.
> > 
> 
> 해당 스크립트 변수부터 살펴 보겠습니다.
> 
> ```csharp
> [SerializeField] private GameObject firePos;  //총알 생성 위치
> public Transform FirePos;
> private LineRenderer laserLine; // 레이저 포인터
> public GameObject bullet; //발사할 총알이펙트
> public GameObject bullet2; //발사할 총알이펙트
> public GunWithHands LeftHand; //왼손 모델링
> public bool ReloadBullet = true;//장전여부
> private bool Hold = false;//잡기
> public int b = 0;//발사한 총알 갯수
> public AudioClip sound; // 재생할 사운드 클립
> public AudioSource audioSource; // AudioSource component를 참조하는 public 변수를 선언합니다. Unity Editor에서 이 변수에 AudioSource component를 연결해주세요.
> public AudioClip audioClip; // 재생하고 싶은 오디오 클립을 참조하는 public 변수를 선언합니다. Unity Editor에서 이 변수에 원하는 오디오 클립을 연결해주세요.
> ```
> 
> 먼저 **firePos** 변수입니다.
> 
> 총알이 생성되어 발사되는 위치를 지정하기 위하여 제작하였습니다.
> 특징으로는 **[SerializeField]** 가 앞에 존재하는것을 볼수 있습니다.
> 이 **[SerializeField]** 는 Unity 에서 사용되는 **어트리뷰트(attribute)** 입니다.
> 해당 **어트리뷰트(attribute)** 를 씀으로써 **Private** 로 선언한 변수라도 **Public**
> 처럼 사용할수 있게 합니다. 
> 
> 해당 **어트리뷰트 변수**를 선언한 이유로는 모델링 수정으로 인하여 선언하여
> 계속 수정이 가능하게 사용하도록 설정하였습니다.
> 
> ---
> 
> 그 다음 **FirePos** 변수입니다.
> 
> 해당 변수는 사격 이펙트를 생성해주는 위치 설정하기 위한 변수입니다. 
> 
> ---
> 
> **laserLine** 변수입니다.
> 
> 해당 변수는 가상의 선이 제대로 적용되고 있는지 파악하기 위하여 **Unity** 에
> 존재하는 **LineRenderer** 속성을 사용하여 레이저 포인터를 표현하기 위해
> 설정하였습니다.
> 
> ---
> 
> 다음은 **bullet** , **bullet2** 변수입니다.
> 
> 사격시 보이는 **Particle** 오브젝트를 설정해주는 변수입니다.
> 
> ---
> 
> **LeftHand** 변수입니다.
> 
> 해당 변수는 총으로 교체하였을때 두 손 모델링이 총을 잡고있는듯한 모션을
> 주기 위하여 설정한 변수 입니다. 
> 
> **GunWithHands** 라는 스크립트를 참조하여 두 스크립트를 연결하여 사용할수 있게
> 하였습니다.
> 
> ---
> 
> **ReloadBullet** 변수입니다.
> 
> 실제 전쟁에 사용되었던 총기인 **“모신나강”** 의 총기 기능중 장전기능을 구현하기
> 위하여 사용되는 변수 입니다.
> 
> ---
> 
> **Hold** 변수입니다.
> 
> 해당 변수는 사용자가 총을 잡고 있는지 확인해주는 변수입니다.
> **Hold** 변수를 통해 사격기능을 활성화 할수 있습니다.
> 
> ---
> 
> **b** 변수는 **Bullet** 의 앞글자만 가져와 사용한 변수입니다.
> 
> 해당 변수는 사격 중 총 몇발의 사격을 하였는지 확인하게 해주는 변수 입니다.
> 
> ---
> 
> **sound** , **audioSource** , **audioClip** 변수입니다.
> 
> 해당 변수는 사격시 발생하는 사격소리 와 장전소리 를 설정해주는 변수입니다.
> 
> ---
> 
> **Start()** 함수입니다.
> 
> ```csharp
>  void Start()
>     {
>         Hold = false;
>         laserLine = GetComponent<LineRenderer>();
>         if (laserLine == null)
>         {
>             laserLine = this.gameObject.AddComponent<LineRenderer>();
>             laserLine.material = new Material(Shader.Find("Standard"));
>             laserLine.startColor = Color.red;
>             laserLine.endColor = Color.red;
>             laserLine.startWidth = 0.01f;
>             laserLine.endWidth = 0.01f;
>         }
>         laserLine.positionCount = 2;
>     }
> ```
> 
> 실행시 총을 잡지않아도 오른쪽 컨트롤러의 **Trigger** 버튼을 누르면 사격이 되는 
> 오류를 수정하기 위하여 **Hold** 변수를 **false** 로 설정하여 총을 잡기 전까진
> 사격을 못하게 설정하였습니다.
> 
> 그 다음 로직으로는 **LineRenderer** 의 컴포넌트를 **laserLine** 에 참조합니다.
> 만약 **LineRenderer** 가 없다면 현재 스크립트가 부착된 오브젝트에 참조합니다.
> 
> 그런 뒤 재질을 **Standard** 를 찾아 적용 시켜준 뒤 레이저의 색을 **Red** 로 설정합니다.
> 그리고 두께를 **0.1** 로 얇게 만들어 줍니다.
> 
> 그렇게 색상과 두께를 정한뒤 **positionCount** 을 사용하여 점을 두개 연결하여 
> 선 을 구현합니다.
> 
> ---
> 
> **OnTriggerEnter()** 와 **OnTriggerExit()** 함수입니다.
> 
> ```csharp
>  private void OnTriggerEnter(Collider other)
>     {
>         if (other.CompareTag("R"))
>         {
>             Debug.Log("잡다");
>             Hold = true;
>         }
> 
>         if (other.gameObject.CompareTag("Bullet") && b == 5)
>         {
>             Debug.Log("장전");
>             ReloadBullet = true;
>             Destroy(other.gameObject);
>             audioSource.PlayOneShot(audioClip);
>             StartCoroutine(Reload());
>             //other.gameObject.SetActive(false);
>             LeftHand.FalseLeftHand();
> 
>         }
>     }
>     
>     private void OnTriggerExit(Collider other)
>     {
>         if (other.CompareTag("R"))
>         {
>             Debug.Log("놓다");
>             Hold = false;
>         }
>     }
> ```
> 
> 먼저 해당 스크립트가 부착되어있는 오브젝트와 **R** 태그가 붙은 오브젝트가 **Trigger**
> 상태라면 **Hold** 변수를 참으로 변환한뒤 **"잡다"** 를 디버깅합니다.
> 
> 그리고 만약 **Bullet** 태그가 붙은 오브젝트와  **Trigger** 상태이고 변수 **b** 의 수가 **5** 와 
> 같다면 함수를 실행하게 조건식을 세웠습니다.
> 
> 함수의 로직은 이러합니다. 
> 
> > **1.  "장전"** 을 디버깅 합니다.
> > 
> > 
> > **2.**  변수 **ReloadBullet** 를 참으로 변환 합니다.
> > 
> > **3.  Bullet** 오브젝트를 파괴합니다.
> > 
> > **4.**  변수 **audioSource** 의 **매개변수**로 지정한 **audioClip** 을 한번 재생합니다.
> > 
> > **5.  Reload** 코루틴을 실행합니다.
> > 
> > **6.  GunWithHands** 스크립트의 함수인 **FalseLeftHand()** 을 실행합니다.
> > 
> 
> ---
> 
> **OnTriggerExit()** 함수는 간단합니다.
> 
> 만약 **R** 태그가 붙은 오브젝트와 **Trigger** 상태가 아니라면 **"놓다"** 를 디버깅합니다.
> 그런뒤 **Hold** 변수의 값을 거짓으로 변환합니다.
> 
> ---
> 
> **Update()** 함수입니다.
> 
> ```csharp
> void Update()
>     {
> 
>         //trigger 누를 때
>         if (OVRInput.GetDown(OVRInput.Button.SecondaryIndexTrigger) && b <= 5 && Hold == true && ReloadBullet == true)
>         {
> 
>             b++;
>             TriggerShoot();
>             //Invoke("TriggerShoot",0f);
>             Debug.Log("누름");
> 
>             GameObject projectile = Instantiate(bullet2, FirePos.position, FirePos.rotation);
> 
>             Destroy(projectile, 0.1f); // Make sure to destroy the instantiated object not the original prefab.
>             GameObject projectile2 = Instantiate(bullet, FirePos.position, FirePos.rotation);
>             AudioSource audioSource = projectile2.AddComponent<AudioSource>();
>             audioSource.clip = sound;
>             audioSource.Play();
>             Destroy(projectile2, 1f); // Make sure to destroy the instantiated object not the original prefab.
>             if (b == 5)
>             {
>                 Debug.Log("장전필요");
>                 ReloadBullet = false;
>                 LeftHand.ActiveLeftHand();
>             }
> 
>         }
>         DrawLaser(firePos.transform.position, firePos.transform.position + firePos.transform.forward * 100);
>         // 함수는 지정된 위치에서 지정된 반경 내에 있는 모든 Collider를 반환합니다.이 결과를 순회하며 "Bullet" 태그가 있는지 확인
>     }
> ```
> 
> 먼저 변수 **b** 의 값이 **5 이하**여야하고 **Hold** 변수의 값과 **ReloadBullet** 변수의 값이 
> 참인 상태에서 오른쪽 컨트롤러의 **Trigger** 버튼을 눌렀을때 함수를 실행합니다.
> 
> 다음은 로직을 설명 드리겠습니다.
> 
> > **1.**  조건식의 조건이 갖춰졌을때 **Tirgger** 버튼을 누르면 변수 **b**의 값을 **1**씩 증가
>     합니다.
> > 
> > 
> > **2.  TriggerShoot()** 를 실행한뒤 **“누름”** 을 디버깅 합니다.
> > 
> > **3.**  변수 **projectile**,**projectile2**  을 설정하여 **bullet**,**bullet2** 을 **FirePos** 변수 
> >     위치에서 생성합니다.
> > 
> > **4.  projectile,projectile2** 은 **0.1** 초뒤에 파괴됩니다.
> > 
> > **5.**  변수 **projectile2** 에 **Audio** 변수 **audioSource** 를 참조하여 소리를 
> >     재생시킨뒤 동일하게 **0.1** 초뒤에 파괴합니다.
> > 
> > **6.**  만약 **b**의 값이 **5**와 동일하다면 **“장전필요”** 를 디버깅한 뒤 **ReloadBullet**
> >     의 값을 거짓으로 변환합니다. 
> > 
> > **7.  GunWithHands** 스크립트의 함수인 **ActiveLeftHand()** 을 실행합니다.
> > 
> > **8.  DrawLaser** 를 실행하여 항상 **firePos** 위치에서 **100** 유닛 만큼의 레이저를 
> >      구현합니다.
> > 
> 
> ---
> 
> **Reload() 코루틴** 함수입니다.
> 
> ```csharp
> public IEnumerator Reload()
>     {
>         yield return new WaitForSeconds(1f);
>         b = 0;
>     }
> ```
> 
> 해당 코루틴이 실행되면 1초간 기다린뒤 변수 **b** 의 값을 **0**으로 바꿉니다.
> 
> ---
> 
> **TriggerShoot()** 함수입니다.
> 
> ```csharp
> public void TriggerShoot()
>     {
>         if (Hold && b < 6)
>         {
>             Ray ray = new Ray(firePos.transform.position, firePos.transform.forward);
>             RaycastHit hitInfo;
> 
>             if (Physics.Raycast(ray, out hitInfo))
>             {
>                 if (hitInfo.collider.tag == "Anemy")
>                 {
>                     Destroy(hitInfo.transform.gameObject);
>                 }
> 
>                 DrawLaser(ray.origin, hitInfo.point);
>             }
>             else
>             {
>                 DrawLaser(ray.origin, ray.origin + ray.direction * 100);
>             }
>         }
>     }
> ```
> 
> 변수 **Hold** 의 값이 참이고 변수 **b**가 **6** 보다 작은지 확인합니다.
> 해당 조건식에 조건이 충족 하다면 함수를 실행합니다.
> 
> 먼저 **Ray 객체**를 변수 **firePos**의 위치 앞에 생성합니다.
> 이때 **RaycastHit** 속성을 사용하여 객체에 **레이캐스트(Raycast)** 가 충돌하였는지 
> 확인합니다.
> 
> 만약 **레이캐스트(Raycast)** 가 **Anemy** 태그가 붙은 오브젝트와 충돌되었다면
> 충돌 지점까지 레이저를 구현하고 **Anemy** 태그가 붙은 오브젝트를 파괴 합니다.
> 
> 그렇지 않다면 레이저를 **100유닛**만큼 구현합니다.
> 
> ---
> 
> **DrawLaser()** 함수입니다.
> 
> ```csharp
> void DrawLaser(Vector3 startPosition, Vector3 endPosition)
>     {
>         laserLine.SetPosition(0, startPosition);
>         laserLine.SetPosition(1, endPosition);
>     }
> ```
> 
> 사용자가 **레이캐스트(Raycast)** 시 사용자의 편의성을 위하여 레이저를 
> 구현해주는 함수입니다.
> 
> 먼저 살펴볼것은 **Vector3** 의 시작점과 종료지점을 매개변수로 받은뒤 
> **laserLine.SetPosition** 의 **0**을 시작지점 **laserLine.SetPosition** 의 **1**을 종료지점으로
> 설정하여 레이저를 구현합니다.
> 
</aside>

### GunWithHands

```csharp
using UnityEngine;

public class GunWithHands : MonoBehaviour
{
    //총 모델링(컨트롤러)를 저장할 게임오브젝트. 총 오브젝트는 꼭 꺼놓아야 함!
    [Tooltip("총 모델링(컨트롤러)를 저장할 게임오브젝트 ")]
    public GameObject GunObject;
    //손 모델링(컨트롤러)을 저장할 게임오브젝트 
    [Tooltip("손 모델링(컨트롤러)을 저장할 게임오브젝트.hands:Rhand(손모델링)를 여기에 드래그드롭. ")]
    public GameObject HandControllerL;
    [Tooltip("손 모델링(컨트롤러)을 저장할 게임오브젝트.CustomLeftH를 여기에 드래그드롭. ")]
    public GameObject HandControllerR;
    [Tooltip("총에 붙어있는 왼손 모델링")]
    public GameObject SecondHandControllerL;
    //인벤토리 활성화 여부를 저장하는 bool값
    private bool inventoryTriggered;
    //왼손 모델링이 꺼진 상태의 bool값
    private bool LHFalse = false;
    public Raycast raycastScript;

    private void Start()
    {

        //시작할 때 총 모델링을 비활성화 해둔다.
        GunObject.SetActive(false);

    }
    private void OnTriggerEnter(Collider other)
    {
        //만약 HandController이라는 태그가 붙어있는 오브젝트가 인벤토리와 충돌될 시,
        if (other.gameObject.CompareTag("R"))
        {
            Debug.Log("Trigger");
            //인벤토리가 활성화된다.
            inventoryTriggered = true;

        }

    }
    private void OnTriggerExit(Collider other)
    {
        //만약 HandController이라는 태그가 붙어있는 오브젝트가 인벤토리와 충돌될 시,
        if (other.gameObject.CompareTag("R"))
        {
            Debug.Log("exit");
            //인벤토리가 비활성화된다.
            inventoryTriggered = false;

        }

    }
    private void Update()
    {
            //VR 컨트롤러의 그랩버튼이 눌린다면
            if (inventoryTriggered && OVRInput.GetDown(OVRInput.Button.SecondaryHandTrigger))
            {
                Debug.Log("Grab");
                //총 오브젝트가 false값이면,
                if (!GunObject.activeSelf && inventoryTriggered)
                {
                    SecondHandControllerL.SetActive(true);
                    //총 모델링이 활성화
                    GunObject.SetActive(true);
                    //인벤토리 작동 확인 로그
                    /*Debug.Log("인벤토리 작동");*/
                    //손 모델링이 비활성화된다.
                    HandControllerL.SetActive(false);
                    HandControllerR.SetActive(false);
                    //총 모델링 사이즈가 변경되는 점을 고정시킨다.
                    GunObject.transform.localScale = new Vector3(0.15f, 0.15f, 0.15f);
                    inventoryTriggered = false;
                    LHFalse = true;

                }
                else if (GunObject.activeSelf && inventoryTriggered)
                {
                        raycastScript.b = 0;
                        raycastScript.ReloadBullet = true;
                        GunObject.SetActive(false);
                        HandControllerL.SetActive(true);
                        HandControllerR.SetActive(true);
                        inventoryTriggered = false;
                        LHFalse = false;
                    }
                }
            }
    

    public void ActiveLeftHand()
    {
        if (LHFalse)
        {
            Debug.Log("왼손 돌아옴..");
            //왼손 활성화
            HandControllerL.SetActive(true);
            SecondHandControllerL.SetActive(false);
            LHFalse = false;
        }
        

    }
    public void FalseLeftHand()
    {
        if (!LHFalse)
        {
            Debug.Log("완손 부착!");
            //왼손 활성화
            HandControllerL.SetActive(false);
            SecondHandControllerL.SetActive(true);
            LHFalse = true;
        }
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **GunWithHands 스크립트 제작중 중점 사항**

> 해당 스크립트는 총기 인벤토리를 구현하기 위한 스크립트입니다.
> 
> 
> 
> 먼저 변수부터 살펴보겠습니다
> 
> ```csharp
> //총 모델링(컨트롤러)를 저장할 게임오브젝트. 총 오브젝트는 꼭 꺼놓아야 함!
> [Tooltip("총 모델링(컨트롤러)를 저장할 게임오브젝트 ")]
> public GameObject GunObject;
> //손 모델링(컨트롤러)을 저장할 게임오브젝트 
> [Tooltip("손 모델링(컨트롤러)을 저장할 게임오브젝트.hands:Rhand(손모델링)를 여기에 드래그드롭. ")]
> public GameObject HandControllerL;
> [Tooltip("손 모델링(컨트롤러)을 저장할 게임오브젝트.CustomLeftH를 여기에 드래그드롭. ")]
> public GameObject HandControllerR;
> [Tooltip("총에 붙어있는 왼손 모델링")]
> public GameObject SecondHandControllerL;
> //인벤토리 활성화 여부를 저장하는 bool값
> private bool inventoryTriggered;
> //왼손 모델링이 꺼진 상태의 bool값
> private bool LHFalse = false;
> public Raycast raycastScript;
> ```
> 
> 변수 **GunObject** 입니다.
> 
> 해당 변수는 **총기 오브젝트**를 저장해주는 변수입니다.
> 
> ---
> 
> 변수 **HandControllerL**,**HandControllerR** 입니다.
> 
> **VR** 상에서 사용되는 **왼손**,**오른손** 모델링을 지정해주는 변수입니다.
> 
> ---
> 
> 변수 **SecondHandControllerL** 입니다.
> 
> 인벤토리에서 꺼낸 총기에 붙어있는 **왼손 모델링**이며 **장전이 필요할때** 
> 총에 붙어있는 **왼손 모델링**을 **비활성화** 하고 **기존의 왼손 모델링**을 **활성화** 
> 하기위한 변수입니다.
> 
> ---
> 
> 변수 **inventoryTriggered** 입니다.
> 
> **인벤토리 기능**을 구현하기 위한 변수이며 해당 변수를 통해 총기를 인벤토리에
> 집어넣고 꺼낼수있게 해주는 변수입니다.
> 
> ---
> 
> 변수 **LHFalse** 이며 총기에 붙어있는 왼손 모델링을 **비활성화** 해주는 변수입니다.
> 
> ---
> 
> **raycastScript** 변수는 스크립트 **Raycast** 의 함수를 사용할수 있게 해주는 변수입니다.
> 
> ---
> 
> **Start()** 함수입니다.
> 
> ```csharp
> private void Start()
>     {
> 
>         //시작할 때 총 모델링을 비활성화 해둔다.
>         GunObject.SetActive(false);
> 
>     }
> ```
> 
> 실행시 **GunObject** 의 오브젝트를 비활성화 해줍니다.
> 
> ---
> 
> **OnTriggerEnter()** 와 **OnTriggerExit()** 함수입니다.
> 
> ```csharp
> private void OnTriggerEnter(Collider other)
>     {
>         //만약 HandController이라는 태그가 붙어있는 오브젝트가 인벤토리와 충돌될 시,
>         if (other.gameObject.CompareTag("R"))
>         {
>             Debug.Log("Trigger");
>             //인벤토리가 활성화된다.
>             inventoryTriggered = true;
> 
>         }
> 
>     }
>     private void OnTriggerExit(Collider other)
>     {
>         //만약 HandController이라는 태그가 붙어있는 오브젝트가 인벤토리와 충돌될 시,
>         if (other.gameObject.CompareTag("R"))
>         {
>             Debug.Log("exit");
>             //인벤토리가 비활성화된다.
>             inventoryTriggered = false;
> 
>         }
> 
>     }
> ```
> 
> 먼저 해당 스크립트가 부착되어있는 오브젝트와 **R** 태그가 붙은 오브젝트가 **Trigger**
> 상태라면 **inventoryTriggered** 변수를 참으로 변환한뒤 **"Trigger"** 를 디버깅합니다.
> 
> ---
> 
> **OnTriggerExit()** 함수도 동일합니다.
> 
> 만약 **R** 태그가 붙은 오브젝트와 **Trigger** 상태가 아니라면 **"exit"** 를 디버깅합니다.
> 그런뒤 **inventoryTriggered** 변수를 거짓으로 변환합니다.
> 
> ---
> 
> **Update()** 함수입니다.
> 
> ```csharp
>  private void Update()
>     {
>             //VR 컨트롤러의 그랩버튼이 눌린다면
>             if (inventoryTriggered && OVRInput.GetDown(OVRInput.Button.SecondaryHandTrigger))
>             {
>                 Debug.Log("Grab");
>                 //총 오브젝트가 false값이면,
>                 if (!GunObject.activeSelf && inventoryTriggered)
>                 {
>                     SecondHandControllerL.SetActive(true);
>                     //총 모델링이 활성화
>                     GunObject.SetActive(true);
>                     //인벤토리 작동 확인 로그
>                     /*Debug.Log("인벤토리 작동");*/
>                     //손 모델링이 비활성화된다.
>                     HandControllerL.SetActive(false);
>                     HandControllerR.SetActive(false);
>                     //총 모델링 사이즈가 변경되는 점을 고정시킨다.
>                     GunObject.transform.localScale = new Vector3(0.15f, 0.15f, 0.15f);
>                     inventoryTriggered = false;
>                     LHFalse = true;
> 
>                 }
>                 else if (GunObject.activeSelf && inventoryTriggered)
>                 {
>                         raycastScript.b = 0;
>                         raycastScript.ReloadBullet = true;
>                         GunObject.SetActive(false);
>                         HandControllerL.SetActive(true);
>                         HandControllerR.SetActive(true);
>                         inventoryTriggered = false;
>                         LHFalse = false;
>                     }
>                 }
>             }
> ```
> 
> 먼저 변수 **inventoryTriggered** 의 값이 **참** 이고 오른쪽 컨트롤러의 **Grab** 버튼을 눌렀을때 함수를 실행합니다.
> 
> 다음은 로직을 설명 드리겠습니다.
> 
> > **1.**  조건식의 조건이 갖춰졌을때 **** **Grab** 버튼을 누르면 **“Grab”** 을 디버깅 합니다.
> > 
> > 
> > **2.**  만약 **GunObject** 가 **비활성화** 이고 **inventoryTriggered** 가 **참** 이라면
> > 
> > **3.**  변수 **SecondHandControllerL** 와 **GunObject** 를 **활성화** 합니다.
> > 
> > **4.  HandControllerL**,**HandControllerR 비활성화** 합니다.
> > 
> > **5.  GunObjec**t 의 오브젝트가 **활성화** 됐을때 커지는 오류가 있어 강제적으로
> >     크기를 고정시켜놨습니다.
> > 
> > **6.  inventoryTriggered** 의 값을 **거짓**으로 변환 하고 **LHFalse** 의 값을 **참**으로 
> >     변환합니다.
> > 
> > **7.  GunObjec**t 의 오브젝트가 **활성화** 되어있고 **inventoryTriggered** 의 값이
> >     **참**이라면 Raycast 스크립트의 사격기능을 초기화 한뒤 비활성화 합니다.
> >     그런 뒤 **HandControllerL**,**HandControllerR 활성화** , **LHFalse** 를 
> >     **비활성화** 합니다.
> > 
> 
> ---
> 
> **ActiveLeftHand()** 함수입니다.
> 
> ```csharp
> public void ActiveLeftHand()
>     {
>         if (LHFalse)
>         {
>             Debug.Log("왼손 돌아옴..");
>             //왼손 활성화
>             HandControllerL.SetActive(true);
>             SecondHandControllerL.SetActive(false);
>             LHFalse = false;
>         }
>     }
> ```
> 
> 해당 함수는 **Raycast** 스크립트가 붙은 오브젝트의 **ReloadBullet()** 의 
> 값이 **참**이 되었을때 **Bullet** 태그가 붙은 오브젝트를 왼손으로 집을수 있게
> **활성화** 시켜주는 함수입니다. 
> 
> 간단하게 로직을 설명드리겠습니다.
> 
> > **1.  LHFalse** 의 값이 **참**이라면 **** **“왼손 돌아옴…”** 을 디버깅 합니다.
> > 
> > 
> > **2.  HandControllerL** 를 **비활성화** 하고 **HandControllerR** 를 **활성화** 합니다.
> > 
> > **3.**  다음으로 **LHFalse**의 값을 **거짓**으로 바꿉니다.
> > 
> 
> ---
> 
> **FalseLeftHand()** 함수입니다.
> 
> ```csharp
> public void FalseLeftHand()
>     {
>         if (!LHFalse)
>         {
>             Debug.Log("완손 부착!");
>             //왼손 활성화
>             HandControllerL.SetActive(false);
>             SecondHandControllerL.SetActive(true);
>             LHFalse = true;
>         }
>     }
> ```
> 
> **ActiveLeftHand()** 함수와 연결되는 함수입니다.
> 
> 로직을 설명드리겠습니다.
> 
> > **1.  LHFalse** 의 값이 **거짓**이라면 **** **“왼손 부착!”** 을 디버깅 합니다.
> > 
> > 
> > **2.  HandControllerL** 를 **활성화** 하고 **HandControllerR** 를 **비활성화** 합니다.
> > 
> > **3.**  다음으로 **LHFalse**의 값을 **참**으로 바꿉니다.
> > 
</aside>

### VR_Fade

```csharp
using UnityEngine;
using System.Collections;

public class VR_Fade : MonoBehaviour
{
    public static VR_Fade instance { get; private set; } // 싱글톤 인스턴스

    public float fadeTime = 2.0f; // 페이드 시간
    public Color fadeColor = new Color(0.01f, 0.01f, 0.01f, 1.0f); // 페이드 색상
    public bool fadeOnStart = true; // 시작 시 페이드 인지 여부
    public int renderQueue = 5000; // 렌더링 순서

    private float explicitFadeAlpha = 0.0f; // 명시적 알파 값
    private float animatedFadeAlpha = 0.0f; // 애니메이션 알파 값
    private float uiFadeAlpha = 0.0f; // UI 알파 값

    private MeshRenderer fadeRenderer; // 메시 렌더러
    private MeshFilter fadeMesh; // 메시 필터
    private Material fadeMaterial = null; // 페이드에 사용할 재질

    void Start()
    {
        if (gameObject.name.StartsWith("OculusMRC_"))
        {
            Destroy(this); // OculusMRC_로 시작하는 이름이면 스크립트 제거
            return;
        }

        // 재질 생성
        fadeMaterial = new Material(Shader.Find("Oculus/Unlit Transparent Color"));
        fadeMesh = gameObject.AddComponent<MeshFilter>();
        fadeRenderer = gameObject.AddComponent<MeshRenderer>();

        var mesh = new Mesh();
        fadeMesh.mesh = mesh;

        Vector3[] vertices = new Vector3[4];
        float width = 5f;
        float height = 5f;
        float depth = 1f;

        // 메시 생성
        vertices[0] = new Vector3(-width, -height, depth);
        vertices[1] = new Vector3(width, -height, depth);
        vertices[2] = new Vector3(-width, height, depth);
        vertices[3] = new Vector3(width, height, depth);

        mesh.vertices = vertices;

        int[] tri = new int[6];

        // 삼각형 생성
        tri[0] = 0;
        tri[1] = 2;
        tri[2] = 1;
        tri[3] = 2;
        tri[4] = 3;
        tri[5] = 1;

        mesh.triangles = tri;

        Vector3[] normals = new Vector3[4];
        normals[0] = -Vector3.forward;
        normals[1] = -Vector3.forward;
        normals[2] = -Vector3.forward;
        normals[3] = -Vector3.forward;

        mesh.normals = normals;

        Vector2[] uv = new Vector2[4];
        uv[0] = new Vector2(0, 0);
        uv[1] = new Vector2(1, 0);
        uv[2] = new Vector2(0, 1);
        uv[3] = new Vector2(1, 1);

        mesh.uv = uv;

        // 시작 시 페이드 인
        if (fadeOnStart)
        {
		        // 해당 부분을 바꿔서 사용하여 Fade In ,Fade out 을 지정할수 있다.
            FadeIn();
        }

        // 싱글톤 인스턴스 설정
        instance = this;
    }
		//Fade In ,Fade out 코루틴
    // 페이드 인
    public void FadeIn()
    {
        StartCoroutine(Fade(1.0f, 0.0f));
    }

    // 페이드 아웃
    public void FadeOut()
    {
        StartCoroutine(Fade(0, 1));
    }

    void OnEnable()
    {
        // 시작 시 페이드가 아니라면 알파값 초기화
        if (!fadeOnStart)
        {
            explicitFadeAlpha = 0.0f;
            animatedFadeAlpha = 0.0f;
            uiFadeAlpha = 0.0f;
        }
    }

    void OnDestroy()
    {
        instance = null;

        // 메시 렌더러, 재질, 메시 필터 제거
        if (fadeRenderer != null)
            Destroy(fadeRenderer);
        if (fadeMaterial != null)
            Destroy(fadeMaterial);
        if (fadeMesh != null)
            Destroy(fadeMesh);
    }

    // UI 알파 값 설정
    public void SetUIFade(float level)
    {
        uiFadeAlpha = Mathf.Clamp01(level);
        SetMaterialAlpha();
    }

    // 명시적 알파 값 설정
    public void SetExplicitFade(float level)
    {
        explicitFadeAlpha = level;
        SetMaterialAlpha();
    }

    // 페이드 코루틴
    IEnumerator Fade(float startAlpha, float endAlpha)
    {
        float elapsedTime = 0.0f;
        while (elapsedTime < fadeTime)
        {
            elapsedTime += Time.deltaTime;
            animatedFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
            SetMaterialAlpha();
            yield return new WaitForEndOfFrame();
        }
        animatedFadeAlpha = endAlpha;
        SetMaterialAlpha();
    }

    // 재질 알파 값 설정
    private void SetMaterialAlpha()
    {
        Color color = fadeColor;
        color.a = Mathf.Max(explicitFadeAlpha, animatedFadeAlpha, uiFadeAlpha);
        if (fadeMaterial != null)
        {
            fadeMaterial.color = color;
            fadeMaterial.renderQueue = renderQueue;
            fadeRenderer.material = fadeMaterial;
            fadeRenderer.enabled = color.a > 0;
        }
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **VR_Fade 스크립트 제작중 중점 사항**

> 프로젝트 전체의 **Fade** 효과를 담당하는 스크립트 입니다.
해당 스크립트의 **Fade In** , **Fade Out** 부분을 설명드리겠습니다.
> 
> 
> ---
> 
> **Start()** 함수 내의 코드
> 
> ```csharp
> if (fadeOnStart)
>         {
> 		        // 해당 부분을 바꿔서 사용하여 Fade In ,Fade out 을 지정할수 있다.
>             FadeIn();
>         }
> ```
> 
> 해당 스크립트의 **Fade** 효과를 담당하는 코드입니다.
> 
> 해당 코드에서 **FadeIn();** 부분을
> 
> ```csharp
> //Fade In ,Fade out 코루틴
>     // 페이드 인
>     public void FadeIn()
>     {
>         StartCoroutine(Fade(1.0f, 0.0f));
>     }
> 
>     // 페이드 아웃
>     public void FadeOut()
>     {
>         StartCoroutine(Fade(0, 1));
>     }
> ```
> 
> 위 **FadeIn()** , **FadeOut()** 둘 중 하나로 사용하여 원하는 **Fade** 효과를 사용할수 
> 있습니다.
> 
> ---
> 
> **Fade() 코루틴** 함수
> 
> ```csharp
> // 페이드 코루틴
>     IEnumerator Fade(float startAlpha, float endAlpha)
>     {
>         float elapsedTime = 0.0f;
>         while (elapsedTime < fadeTime)
>         {
>             elapsedTime += Time.deltaTime;
>             animatedFadeAlpha = Mathf.Lerp(startAlpha, endAlpha, Mathf.Clamp01(elapsedTime / fadeTime));
>             SetMaterialAlpha();
>             yield return new WaitForEndOfFrame();
>         }
>         animatedFadeAlpha = endAlpha;
>         SetMaterialAlpha();
>     }
> ```
> 
> **FadeIn()** , **FadeOut()** 함수 둘 다 **Fade() 코루틴** 함수 를 사용하여 움직입니다.
> 
> ---
> 
> 해당 스크립트는 **싱글톤(Singleton)** 을 사용하여 Unity 내에 존재하는 
> 다른 **Scene** 으로 이동하더라도 **절대 파괴되지 않으며** 새로운 **인스턴스**를
> 생성하지 않습니다.
> 
</aside>

### TeleportMove

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class TeleportMove : MonoBehaviour
{
    public VR_Fade VRFade;
    public Transform Finishpoint;
    public GameObject Player;

    // Start is called before the first frame update
    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            
            StartCoroutine(TeleportPlayer());
            
        }
        
    }

    IEnumerator TeleportPlayer()
    {
        // 페이드아웃 시작
        VRFade.FadeOut();
        // 페이드아웃이 완료될 때까지 기다림
        yield return new WaitForSeconds(VRFade.fadeTime);

        // 플레이어를 지정한 위치로 이동
        Player.transform.position = Finishpoint.position;

        // 페이드인 시작
        VRFade.FadeIn();

    }
}
```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **TeleportMove 스크립트 제작중 중점 사항**

> 프로젝트 내에서 사용자가 다른 위치 로 **이동**할수 있게 해주는 스크립트 입니다.
> 
> 
> 변수부터 설명 드리겠습니다.
> 
> ```csharp
> public VR_Fade VRFade;
> public Transform Finishpoint;
> public GameObject Player;
> ```
> 
> **VRFade** 변수입니다.
> 
> 해당 변수는 **VR_Fade** 스크립트의 **Fade** 효과를 사용할 수 있게 해주는 변수입니다.
> 
> ---
> 
> **Finishpoint** 변수는 사용자가 **이동할 위치**를 설정하는 변수입니다.
> 
> ---
> 
> **Player** 변수입니다.
> 
> 해당 변수는 **사용자를 설정**하는 변수이며 해당변수를 통해 사용자를 
> **Finishpoint** 변수 위치로 이동시켜줍니다.
> 
> ---
> 
> **OnTriggerEnter()** 함수입니다.
> 
> ```csharp
> private void OnTriggerEnter(Collider other)
>     {
>         if (other.CompareTag("Player"))
>         {  
>             StartCoroutine(TeleportPlayer());
>         }
>     }
> ```
> 
> 해당 함수는 **Player** 태그가 붙은 오브젝트와 **Trigger** 상태라면 **TeleportPlayer()**
> **코루틴**을 실행 시킵니다.
> 
> ---
> 
> **TeleportPlayer() 코루틴** 함수입니다.
> 
> ```csharp
> IEnumerator TeleportPlayer()
>     {
>         // 페이드아웃 시작
>         VRFade.FadeOut();
>         // 페이드아웃이 완료될 때까지 기다림
>         yield return new WaitForSeconds(VRFade.fadeTime);
> 
>         // 플레이어를 지정한 위치로 이동
>         Player.transform.position = Finishpoint.position;
> 
>         // 페이드인 시작
>         VRFade.FadeIn();
>     }
> ```
> 
> 해당 **코루틴**은 실행시 **VR_Fade** 스크립트의 **FadeOut()** 함수를 실행시켜 **Fade** 가
> 끝날 때 까지 대기한뒤 **Player** 변수 오브젝트의 위치를 **Finishpoint** 변수 위치값으로
> 이동 시키고  **VR_Fade** 스크립트의 **FadeIn()** 함수를 실행시킵니다.
> 
</aside>

### SceneChange

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneChange : MonoBehaviour
{
    public string nextSceneName; // 전환할 씬의 이름을 지정해주세요.
    public VR_Fade VRFade;

    private void OnTriggerEnter(Collider other)
    {
        StartCoroutine(ChangeScene());
    }

    IEnumerator ChangeScene()
    {
        VRFade.FadeOut();
        // 페이드아웃이 완료될 때까지 기다림
        yield return new WaitForSeconds(VRFade.fadeTime);
        // 페이드아웃이 끝나면 씬을 전환합니다.
        SceneManager.LoadScene(nextSceneName);
    }
}

```

### TimerScene

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class TimerScene : MonoBehaviour
{
    public string nextSceneName; // 전환할 씬의 이름을 지정해주세요.
    public VR_Fade VRFade;
    public float delayTime = 3f; // 페이드 아웃 후 대기할 시간 (초)

    private void OnTriggerEnter(Collider other)
    {
        StartCoroutine(ChangeScene());
    }

    IEnumerator ChangeScene()
    {
        VRFade.FadeOut();
        // 페이드아웃이 완료될 때까지 기다림
        yield return new WaitForSeconds(VRFade.fadeTime);
        // 페이드 아웃이 끝난 후 지정한 시간만큼 대기
        yield return new WaitForSeconds(delayTime);

        // 대기 시간이 끝나면 씬을 전환합니다.
        SceneManager.LoadScene(nextSceneName);
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **SceneChange,TimerScene 스크립트 제작중 중점 사항**

> 프로젝트 내에서 사용자가 다른 **Scene** 으로 **이동**할수 있게 해주는 스크립트 와
**일정 시간이 지난뒤** 다른 **Scene** 으로 **이동**할수 있게 해주는 스크립트입니다.
> 
> 
> 먼저 **SceneChange**변수부터 설명 드리겠습니다.
> 
> ```csharp
>   public string nextSceneName; // 전환할 씬의 이름을 지정해주세요.
> 	public VR_Fade VRFade;
> ```
> 
> **nextSceneName** 변수입니다.
> 
> 해당 변수는 **String** 속성 변수로써 원하는 **Scene** 의 이름을 **Unity** 안에서 기입하여
> 원하는 **Scene** 으로 이동할수 있는 변수 입니다.
> 
> ---
> 
> **VRFade** 변수입니다.
> 
> 해당 변수는 **VR_Fade** 스크립트의 **Fade** 효과를 사용할 수 있게 해주는 변수입니다.
> 
> ---
> 
> **TimerScene** 변수입니다.
> 
> ```csharp
> public string nextSceneName; // 전환할 씬의 이름을 지정해주세요.
> public VR_Fade VRFade;
> public float delayTime = 3f; // 페이드 아웃 후 대기할 시간 (초)
> ```
> 
> **SceneChange**변수 와 동일한 부분이 있어 **delayTime** 변수만 설명드리겠습니다.
> 
> 해당 변수는 **FadeOut()** 효과가 끝난뒤 **3초간 대기** 하게 해주는 변수입니다. 
> 
> ---
> 
> **SceneChange,TimerScene** 스크립트의 **OnTriggerEnter()** 함수입니다.
> 
> ```csharp
> private void OnTriggerEnter(Collider other)
>     {
>         StartCoroutine(ChangeScene());
>     }
> ```
> 
> 해당 함수는 해당 스크립트가 붙은 오브젝트와 **Trigger** 상태라면 **ChangeScene()**
> **코루틴**을 실행 시킵니다.
> 
> ---
> 
> **SceneChange** 스크립트의 **ChangeScene() 코루틴** 함수입니다.
> 
> ```csharp
> IEnumerator ChangeScene()
>     {
>         VRFade.FadeOut();
>         // 페이드아웃이 완료될 때까지 기다림
>         yield return new WaitForSeconds(VRFade.fadeTime);
>         // 페이드아웃이 끝나면 씬을 전환합니다.
>         SceneManager.LoadScene(nextSceneName);
>     }
> ```
> 
> 해당 **코루틴**은 실행시 **VR_Fade** 스크립트의 **FadeOut()** 함수를 실행시켜 **Fade** 가
> 끝날 때 까지 대기한뒤 **nextSceneName** 변수의 문자열과 같은 **Scene** 으로 
> 이동합니다.
> 
> ---
> 
> **TimerScene** 스크립트의 **ChangeScene() 코루틴** 함수입니다.
> 
> ```csharp
> IEnumerator ChangeScene()
>     {
>         VRFade.FadeOut();
>         // 페이드아웃이 완료될 때까지 기다림
>         yield return new WaitForSeconds(VRFade.fadeTime);
>         // 페이드 아웃이 끝난 후 지정한 시간만큼 대기
>         yield return new WaitForSeconds(delayTime);
> 
>         // 대기 시간이 끝나면 씬을 전환합니다.
>         SceneManager.LoadScene(nextSceneName);
>     }
> ```
> 
> **SceneChange** 스크립트의 **ChangeScene() 코루틴** 함수와 동일하나 
> **WaitForSeconds(delayTime);** 의 매개변수인 **delayTime** 만큼 대기한뒤
> **nextSceneName** 변수의 문자열과 같은 **Scene** 으로 이동합니다.
> 
</aside>
